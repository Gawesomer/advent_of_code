(defun parse-points (input-line)
  (let* ((res (list (list :x NIL :y NIL) (list :x NIL :y NIL)))
         (split-line (cl-utilities:split-sequence #\, input-line))
         (splitter-line (cl-utilities:split-sequence #\Space (second split-line))))
    (setf (getf (first res) :x) (parse-integer (first split-line)))
    (setf (getf (first res) :y) (parse-integer (first splitter-line)))
    (setf (getf (second res) :x) (parse-integer (third splitter-line)))
    (setf (getf (second res) :y) (parse-integer (third split-line)))
    res))

(defun get-input-lines ()
  "Reads lines from file named input.txt"
  (with-open-file (in "input.txt")
    (loop for line = (read-line in nil nil)
          while line
          collect (parse-points line))))

(defun max-x (lines)
  (do ((i 0 (1+ i))(curr 0))
      ((eql i (length lines)) curr)
    (if (> (getf (first (nth i lines)) :x) curr)
        (setf curr (getf (first (nth i lines)) :x)))
    (if (> (getf (second (nth i lines)) :x) curr)
        (setf curr (getf (first (nth i lines)) :x)))))

(defun max-y (lines)
  (do ((i 0 (1+ i))(curr 0))
      ((eql i (length lines)) curr)
    (if (> (getf (first (nth i lines)) :y) curr)
        (setf curr (getf (first (nth i lines)) :y)))
    (if (> (getf (second (nth i lines)) :y) curr)
        (setf curr (getf (first (nth i lines)) :y)))))

;(print (max-x (get-input-lines)))
;(print (max-y (get-input-lines)))

(defun line->points (line)
  (if (eql (getf (first line) :x) (getf (second line) :x))
      (return-from line->points (do ((i (min (getf (first line) :y) (getf (second line) :y)) (1+ i))
                                     (points NIL))
                                    ((> i (max (getf (first line) :y) (getf (second line) :y))) points)
                                  (push (list :x (getf (first line) :x) :y i) points))))
  (if (eql (getf (first line) :y) (getf (second line) :y))
      (return-from line->points (do ((i (min (getf (first line) :x) (getf (second line) :x)) (1+ i))
                                     (points NIL))
                                    ((> i (max (getf (first line) :x) (getf (second line) :x))) points)
                                  (push (list :x i :y (getf (first line) :y)) points))))
  (do ((x (getf (first line) :x) (if (> (getf (second line) :x) x)
                                     (1+ x)
                                     (1- x)))
       (y (getf (first line) :y) (if (> (getf (second line) :y) y)
                                     (1+ y)
                                     (1- y)))
       (points NIL))
      ((eql x (getf (second line) :x)) (push (second line) points))
    (push (list :x x :y y) points)))

(defun fill-arr (lines)
  (let ((arr (make-array '(990 990) :initial-element 0)) (overlap 0))
    (dolist (line lines)
      (print line)
      (dolist (point (line->points line))
        (print point)
        (incf (aref arr (getf point :x) (getf point :y)))))
    (dotimes (x 990)
      (dotimes (y 990)
        (if (> (aref arr x y) 1)
            (incf overlap))))
    (print arr)
    overlap))

(print (fill-arr (get-input-lines)))
